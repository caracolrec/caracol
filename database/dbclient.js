//dbclient.js

var tables = require('./dbschemas.js');
var algorithm = require('../controllers/algorithm.js');
var _ = require('underscore');
var crypto = require('crypto');

// convert a datetime in ISO format generated by Javascript's Date object into Postgres format
var dateTransform = function(ISOdatetime) {
  ISOdatetime = ISOdatetime.replace('T',' ');
  ISOdatetime = ISOdatetime.slice(0,19);
  ISOdatetime = ISOdatetime + '+00';
  return ISOdatetime;
};

var insertUserClipping = function(user_id, clipping_id, callback){
  new tables.User_Clipping({
    user_id: user_id,
    clipping_id: clipping_id
  })
  .save()
  .then(function(model){
    console.log('success to the user clipping table:', model.attributes);
    callback(null, model.attributes.clipping_id);
  }, function(error){
    console.log('error adding to user_clippings', error);
  });
};

var makeSalt = function() {
  return Math.round((new Date().valueOf() * Math.random())) + '';
};
  
var encryptPassword = function(password, salt){
  if (!password) { return ''; }
  salt = salt || makeSalt();
  var hashed_password = crypto.createHmac('sha1', salt).update(password).digest('hex');
  return {
    password_salt: salt,
    hashed_password: hashed_password
  };
};

exports.createUser = createUser = function(json, callback){
  console.log('json looks like:', json);
  var creds = encryptPassword(json.password);
  var lowerUsername = json.username.toLocaleLowerCase();
  new tables.User()
  .query(function(qb) {
    qb.where({username: lowerUsername});
  })
  .fetch({require: true})
  .then(function(model){
    console.log('results of username lookup:', model);
    callback('username already exists');
  }, function(err){
    console.log("no user by that username found, so we'll create one");
    new tables.User({
      username: lowerUsername,
      password_salt: creds.password_salt,
      hashed_password: creds.hashed_password
    })
    .save()
    .then(function(model){
      console.log('user successfully saved:', model.id);
      callback(null, {
        id: model.id,
        username: model.attributes.username
      });
    }, function(error){
      console.log('error creating new user:', error);
      callback(error);
    });
  });
};

exports.findUser = findUser = function(json, callback){
  var user = new tables.User({
    username: json.username.toLocaleLowerCase(),
  })
  .fetch({require: true})
  .then(function(model) {
    console.log('found user');
    var creds = encryptPassword(json.password, model.attributes.password_salt);
    if (model.attributes.hashed_password === creds.hashed_password) {
      callback(null, {
        id: model.id,
        username: model.attributes.username
      });
    } else {
      callback('incorrect password');
    }
  }, function(error){
    console.log('please signup!', error);
    callback(error);
  });
};

exports.dbInsert = dbInsert = function(json, user_id, callback){
  checkForClipping(json);
  new tables.Clipping({
    title: json.title,
    content: json.content,
    uri: json.url,
    word_count: json.word_count,
    first_insert: dateTransform(new Date().toISOString()),
    total_pages: json.total_pages,
    date_published: json.date_published,
    dek: json.dek,
    lead_image_url: json.lead_image_url,
    //next_page_id: json.next_page_id, // occasionally parser returns a non-integer for this field which causes error
    rendered_pages: json.rendered_pages
  })
  .save()
  .then(function(model) {
    insertUserClipping(user_id, model.id, callback);
    //algorithm.removeHTMLAndTokenize(model.id, function(){});
    return algorithm.processNewArticle(model.id, user_id, function(){});
  }, function(error){
    console.log('Error saving the clipping:', error);
    callback(error);
  });
};

exports.checkForClipping = checkForClipping = function(json, user_id, callback){
  new tables.Clipping()
  .query()
  .where({title: json.title})
  .then(function(model){
    if (json.title === ''){
      dbInsert(json, user_id, callback);
    } else if (model.length) {
      insertUserClipping(user_id, model[0].id, callback);
      console.log("content model", model[0].id);
    } else {
      dbInsert(json, user_id, callback);
    }
  }, function(err){
    console.log('error', error);
  });
};

exports.fetch = fetch = function(clippings_or_recs, user_id, fetchOlderThanThisId, batchSize, callback) {
  console.log('fetchClippingsOlderThanThisClippingId:',fetchOlderThanThisId);
  console.log('batchSize is:', batchSize);
  var coll, orderBy;
  if (clippings_or_recs === 'clippings') {
    orderBy = ['id', 'desc'];
    coll = new tables.User_Clippings();
  } else if (clippings_or_recs === 'recs') {
    orderBy = ['rank', 'asc'];
    coll = new tables.Recommendations();
  }

  var queryBuilder;
  if (fetchOlderThanThisId === 0) {
    queryBuilder = function(qb) {
      qb
      .where('user_id', '=', user_id)
      .orderBy(orderBy[0], orderBy[1])
      .limit(batchSize);
    };
  } else {
    queryBuilder = function(qb) {
      qb
      .where('id', '<', fetchOlderThanThisId)
      .andWhere('user_id', '=', user_id)
      .orderBy(orderBy[0], orderBy[1])
      .limit(batchSize);
    };
  }
  coll.query(queryBuilder)
  .fetch({ withRelated: ['clipping'] })
  .then(function(results) {
    console.log('successfully grabbed', clippings_or_recs, 'from the db:', results);
    callback(null, results);
  }, function(error) {
    console.log('there was an error fetching', clippings_or_recs, 'from the db:', error);
    callback(error);
  });
};

exports.dbVote = dbVote = function(json){
  //update query update user clippings set vote where user clipping ==
  console.log('called', json);
  new tables.User_Clipping()
  .query()
  .where({user_id: json.user_id, clipping_id: json.clipping_id})
  .then(function(model){
    console.log(model[0].id);
    new tables.User_Clipping({id: model[0].id})
    .save({vote: json.vote}).then(function(model){
      console.log('successfully saved vote:', model);
    }, function(error){
      console.log('error saving to userclipping id:', error);
    });
  }, function(error){
    console.log('error voting:', error);
  });
};
